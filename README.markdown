This is Parley.  It's better than what you have.

### Coding Standards
I got here first, so I get to make the rules.

![thbbft!](http://www.mortalwombat.com/Special/BilltheCat.jpg)

Lines wrap at 80 chars, at least in the `app` folder.  Other folders, especially
ones with autogenerated files, can be a little more lax about this.

Indentation is two spaces, never tabs.  Unix line endings.

I've been using [TomDoc](https://github.com/mojombo/tomdoc/blob/master/tomdoc.md)
style comments for things that aren't trivial.  We aren't actually running
TomDoc on anything right now, so nothing will break if you do something else,
but it's a pretty good standard.

### Conversations and Events
The way I ended up constructing conversations is not entirely trivial, so I'll
give it a note here as well as in whatever comments I end up writing.

At a high level, conversations are Parley's first-class object, not messages.
At a low level, though, `Conversation` objects nearly don't exist.  They just
have an id that can get related to users and events.  Everything that actually
goes in the database is composed of events that users do to conversations, of
which writing in them is just one (albeit, important) kind.

Originally I had planned on having conversations, events *and* messages, but
then I realized that would make the queries needed to construct a conversation
view tragically complicated.  The crux of the problem is stitching together
things that aren't messages (renaming a conversation, forking a thread,
removing a person from a thread, etc) and things that are messages into a single
coherent stream.  In order to do that we'd have to end up doing either multiple
or one fiendishly complex query from the database and creating objects that
could polymorphically be either a message or an event that we could then pass
off to the view to render as it see fit.

It'll be easier if everything is an event, and messages are just a special case
of that (the "wrote" event).  The downside to this is that in order to get the
current state of a conversation we have to pull out all the events and process
them into things that I've called 'conversation pieces'.  This is similar to
some of the complexity I described above, but I think that keeping everything as
one kind of object in the database and model layers will pay off.

One final note about the database.  However we did them (separate from messages,
or including messages) one big problem with events is that there's a bunch of
kinds of them and they all the slightly different kinds of data attached to
them.  "Deleted" events just need a message id, while "forked" events need a
message id and the new thread id, "removed a person" events need a user id, and
so on. Instead of making a giant terrible mess of database tables for each kind
of event, events all get just one row.  It has a conversation id (the
conversation the event happened to) a user id (the user who performed the
event), a string for the event type and a text field for extra json data.
Events of the same type should all have the same stuff in their data field, but
I'm not bothering with getting the database to verify that for me.  So Codd
would be upset with me, but fuck it.
